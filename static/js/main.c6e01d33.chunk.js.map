{"version":3,"sources":["config.js","sysex/hex2sysex.js","request/request.js","settings.js","startup.js","App.js","serviceWorker.js","index.js"],"names":["config","sysexAddress","input","output","keepWatching","OUT_CMD_ADDR","getEmptyBytes","numberOfWholeBytes","bytes","i","push","getAsHalfBytes","halfBytes","Array","forEach","byte","Math","floor","num","reverse","parseLines","lines","dataBlocks","mode","addressOffset","lineNum","line","substring","_parseLine","dataLength","parseInt","originalAddress","dataEnd","address","type","data","checksum","parseLine","console","log","concat","getMode","getModeString","byteString","length","getHexStringAsByteArray","toString","getMissingEndBytes","blockSize","mergeAndPadBlocks","blocks","_lastMerged$data","currentBlock","mergedBlocks","currentAddress","currentEndBlockNum","block","_currentBlock$data3","blockNum","getStartBlockNum","_currentBlock$data","missingBytes","apply","Object","toConsumableArray","_currentBlock$data2","getEndBlockNum","lastMerged","splitByBlockSize","splitBlocks","sliceData","slice","dataString","join","convertFileToSysex","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","fileLines","parsedBlocks","mergedProgramBlocks","splitProgramBlocks","sysexBlocks","wrap","_context","prev","next","filter","sort","b","map","abrupt","stop","this","_x","_x2","arguments","fetchAsText","_ref2","url","path","fetch","then","response","text","getSysexAddress","addressBytes","split","trim","getSettings","timeout","ms","Promise","res","setTimeout","asyncForEach","array","callback","index","parseAndUploadFile","_ref3","_callee3","delayBetweenBlocks","statusCallback","hexDataParts","sysexStart","sysexEnd","partNum","_context3","sent","_ref4","_callee2","part","percentageCompleted","_context2","write","_x4","_x3","run","_ref5","_callee4","file","settings","inputfile","_context4","t0","_x5","_x6","_x7","App","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","midiAccess","outputs","selectedOutput","selectedFirmware","writing","statusText","_this$state","setState","get","id","navigator","requestMIDIAccess","sysex","onstatechange","e","port","connection","_this2","updateOutputs","event","target","value","firmware","_this3","send","_this4","disableButton","react_default","createElement","className","onChange","selectOutput","key","name","selectFirmware","disabled","onClick","writeFirmware","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c6e01d33.chunk.js","sourcesContent":["const config = {\n  sysexAddress: '0x00, 0x2B, 0x66',\n  input: './input.hex',\n  output: './output.sysex',\n  keepWatching: false,\n};\n\nexport default config;","// @flow\nexport const TYPE_DATA = 0;\nexport const TYPE_EOF = 1;\nexport const TYPE_LINEAR_ADDR = 2;\nexport const TYPE_EXTENDED_ADDR = 4;\n\nexport const MODE_UNKNOWN = -1;\nexport const MODE_PROGRAM = 0;\nexport const MODE_CONFIG = 1;\nexport const MODE_EEPROM = 2;\nexport const MODE_USER_ID = 3;\n\nconst EXT_ADDR_PROGRAM = '0000';\nconst EXT_ADDR_USER_ID = '0020';\nconst EXT_ADDR_CONFIG_BYTES = '0030';\nconst EXT_ADDR_EEPROM_BYTES = '00F0';\n\nconst OUT_CMD_ADDR = 0x10;\nconst OUT_CMD_DATA = 0x11;\nconst OUT_CMD_EOF = 0x12;\n\nconst getTypeString = (type: number) => {\n  switch (type) {\n    case TYPE_DATA:\n      return 'data';\n    case TYPE_EOF:\n      return 'eof';\n    case TYPE_LINEAR_ADDR:\n      return 'linear address';\n    case TYPE_EXTENDED_ADDR:\n      return 'extended address';\n    default:\n      return 'unknown';\n\n  }\n};\n\nconst getModeString = (mode: number) => {\n  switch (mode) {\n    case MODE_PROGRAM:\n      return 'program bytes';\n    case MODE_CONFIG:\n      return 'user id';\n    case MODE_EEPROM:\n      return 'config bytes';\n    case MODE_USER_ID:\n      return 'eeprom bytes';\n    default:\n      return 'unknown';\n\n  }\n};\n\nexport const getEmptyBytes = (numberOfWholeBytes: number) => {\n  const bytes = [];\n  for (let i = 0; i < numberOfWholeBytes; i++) {\n    bytes.push(255);\n  }\n  return bytes;\n};\n\nexport const getHexStringAsByteArray = (byteString: string) => {\n  const bytes = [];\n  for (let i = 0; i < byteString.length; i += 2) {\n    bytes.push(parseInt(byteString.substring(i, i + 2), 16));\n  }\n  return bytes;\n};\n\nexport const getAsHalfBytes = (bytes: Array<number> | number): Array<number> => {\n  const halfBytes = [];\n  if (bytes instanceof Array) {\n    bytes.forEach(byte => {\n      halfBytes.push(Math.floor(byte / 16));\n      halfBytes.push((byte + 16) % 16);\n    });\n    return halfBytes;\n  } else {\n    let num = bytes;\n    do {\n      halfBytes.push((num + 16) % 16);\n      num = num >> 4;\n      halfBytes.push((num + 16) % 16);\n      num = num >> 4;\n    } while (num !== 0);\n\n    return halfBytes.reverse();\n  }\n};\n\nexport const parseLine = (line: string, addressOffset: number) => {\n  const dataLength = parseInt(line.substring(1, 3), 16);\n  const originalAddress = parseInt(line.substring(3, 7), 16);\n  const address = addressOffset + originalAddress;\n  const type = parseInt(line.substring(7, 9), 16);\n  const dataEnd = 9 + dataLength * 2;\n  const data = line.substring(9, dataEnd);\n  const checksum = line.substring(dataEnd, dataEnd + 2);\n\n  return {\n    dataLength,\n    address,\n    originalAddress,\n    type,\n    data,\n    checksum,\n  };\n};\n\nexport const getMode = (data: string) => {\n  if(data === EXT_ADDR_PROGRAM){\n    return MODE_PROGRAM;\n  } else if (data === EXT_ADDR_CONFIG_BYTES) {\n    return MODE_CONFIG;\n  } else if (data === EXT_ADDR_EEPROM_BYTES) {\n    return MODE_EEPROM;\n  } else if (data === EXT_ADDR_USER_ID) {\n    return MODE_USER_ID;\n  } else {\n    return MODE_UNKNOWN;\n  }\n};\n\nexport const parseLines = (lines: Array<string>) => {\n  const dataBlocks = [];\n  let mode = MODE_PROGRAM;\n  let addressOffset = 0;\n  let lineNum = 1;\n  lines.forEach(line => {\n\n    // remove lines not containing instructions\n    if (line.substring(0, 1) === ':') {\n      const { type, address, originalAddress, data, checksum } = parseLine(line, addressOffset);\n\n      if (type === TYPE_LINEAR_ADDR) {\n        addressOffset = 16 * parseInt(data, 16);\n        console.log(`${lineNum} changed address offset to ${addressOffset} (${line})`);\n      } else if (type === TYPE_EXTENDED_ADDR) {\n        addressOffset = 65536 * parseInt(data, 16);\n        mode = getMode(data);\n        console.log(`${lineNum} changed address offset to ${addressOffset}, mode: ${getModeString(mode)} (${line})`);\n      } else if (type === TYPE_DATA) {\n        // TODO: No address offset for EEPROM ETC?\n        dataBlocks.push({\n          address,\n          data: getHexStringAsByteArray(data),\n          mode,\n          checksum,\n        });\n        console.log(`${lineNum}, addr: 0x${address.toString(16)} (${address}), orig: 0x${originalAddress.toString(16)}, bytes: ${data.length / 2}, data: ${data}`);\n      } else if(type === TYPE_EOF){\n        console.log(`EOF found, address: ${address}, data: ${data}, checksum: ${checksum}`);\n      } else {\n        console.log(\"Unknown type encountered: \", type, address, data, checksum);\n      }\n    } else {\n      console.log(\"Unknown line format encountered: \", line)\n    }\n    lineNum++;\n  });\n\n  console.log('Finished parsing lines');\n  return dataBlocks;\n};\n\nexport const getBlockAlignedAddress = (address: number, blockSize: number) => {\n  return Math.floor(address / blockSize) * blockSize;\n};\n\nexport const getStartBlockNum = (address: number, blockSize: number) => {\n  return Math.floor(address / blockSize);\n};\n\nexport const getEndBlockNum = (address: number, length: number, blockSize: number) => {\n  return Math.floor((address + length) / blockSize);\n};\n\nexport const getMissingEndBytes = (address: number, length: number, blockSize: number) => {\n  return blockSize - (blockSize + address + length) % blockSize; // adding blockSize to prevent negative number. % in js is weird.\n};\n\nexport const mergeAndPadBlocks = (blocks, blockSize) => {\n  const mergedBlocks = [];\n  let currentBlock;\n  let currentAddress = 0;\n  let currentEndBlockNum = -2;\n\n  blocks.forEach(block => {\n    const blockNum = getStartBlockNum(block.address, blockSize);\n\n    // if there is at least one full block between entries, create a new merged block.\n    if (blockNum !== currentEndBlockNum && blockNum !== currentEndBlockNum + 1) {\n      // add missing bytes from last block\n      if (currentBlock != null) {\n        const missingBytes = getMissingEndBytes(currentAddress, 0, blockSize);\n        if (missingBytes) {\n          currentBlock.data.push(...getEmptyBytes(missingBytes));\n        }\n      }\n\n      // create new block\n      currentAddress = blockNum * blockSize;\n      currentBlock = {\n        address: currentAddress,\n        data: [],\n      };\n      mergedBlocks.push(currentBlock);\n    }\n\n    // add missing bytes between blocks\n    const missingBytes = block.address - currentAddress;\n    if (missingBytes) {\n      currentBlock.data.push(...getEmptyBytes(missingBytes));\n    }\n    currentBlock.data.push(...block.data);\n\n    currentEndBlockNum = getEndBlockNum(block.address, block.data.length, blockSize);\n    currentAddress = block.address + block.data.length;\n  });\n\n  // add bytes missing from the last merged block - missing end bytes are normally added on the\n  // next iteration, but the last block has no next.\n  const lastMerged = mergedBlocks[mergedBlocks.length - 1];\n  const missingBytes = getMissingEndBytes(lastMerged.address, lastMerged.data.length, blockSize);\n  lastMerged.data.push(...getEmptyBytes(missingBytes));\n  return mergedBlocks;\n};\n\nexport const splitByBlockSize = (mergedBlocks, blockSize) => {\n  // split blocks to block size\n  const splitBlocks = [];\n\n  mergedBlocks.forEach(block => {\n    for (let i = 0; i < block.data.length; i += blockSize) {\n      const sliceData = block.data.slice(i, i + blockSize);\n      splitBlocks.push({\n        data: sliceData,\n        dataString: sliceData.join(),\n        address: block.address + i\n      });\n    }\n  });\n  return splitBlocks;\n};\n\nexport const convertFileToSysex = async (\n  fileLines: Array<string>, blockSize: number): Promise<Array<number>> => {\n  const parsedBlocks = parseLines(fileLines);\n\n  // Data blocks may not be ordered by address. In order to pad the blocks correctly we have to\n  // sort them.\n  const dataBlocks = parsedBlocks\n    .filter(block => block.mode === MODE_PROGRAM)\n    .sort((a, b) => a.address - b.address);\n\n  const mergedProgramBlocks = mergeAndPadBlocks(dataBlocks, blockSize);\n  const splitProgramBlocks = splitByBlockSize(mergedProgramBlocks, blockSize);\n\n  const sysexBlocks = splitProgramBlocks.map(block => {\n    return [\n      OUT_CMD_ADDR,\n      ...getAsHalfBytes(block.address),\n      OUT_CMD_DATA,\n      ...getAsHalfBytes(block.data),\n    ]\n  });\n  sysexBlocks.push([OUT_CMD_EOF]);\n  return sysexBlocks;\n};\n","export const fetchAsText = async ({url, path}: {url: ?string, path: string}): Promise<*> => {\n  return fetch(`${url}${path}`)\n    .then(response => {\n      return response.text();\n    });\n};\n","// @flow\nimport config from './config';\n\nconst getConfigValue = (name) => config[name];\n\nconst getSysexAddress = () => {\n  const sysexAddress = getConfigValue('sysexAddress');\n  if (sysexAddress == null) {\n    console.log('Sysex address is missing');\n    return null;\n  }\n\n  const addressBytes = sysexAddress\n    .split(',')\n    .map(byte => byte.trim())\n    .map(byte => parseInt(byte));\n\n  if (addressBytes.length !== 3) {\n    console.log(\"Error: Sysex address must be exactly 3 bytes long.\");\n    return null;\n  }\n  console.log(`Using sysex address ${addressBytes[0]}, ${addressBytes[1]}, ${addressBytes[2]}`);\n  return addressBytes;\n\n};\n\nexport const getSettings = () => {\n\n  const sysexAddress = getSysexAddress();\n  if (sysexAddress === null) {\n    return null;\n  }\n\n  return {\n    sysexAddress,\n  }\n};","// @flow\nimport config from './config';\nimport { convertFileToSysex } from \"./sysex/hex2sysex\";\nimport { fetchAsText } from \"./request/request\";\nimport { getSettings } from \"./settings\";\n\nconst timeout = ms => new Promise(res => setTimeout(res, ms));\n\nconst asyncForEach = async (array, callback) => {\n  for (let index = 0; index < array.length; index++) {\n    await callback(array[index], index, array)\n  }\n};\n\nconst parseAndUploadFile = async (\n  {\n    sysexAddress,\n    fileLines,\n    output,\n    delayBetweenBlocks,\n    statusCallback,\n  }\n) => {\n  const hexDataParts = await convertFileToSysex(fileLines, 64);\n  const sysexStart = [0xF0, ...sysexAddress];\n  const sysexEnd = [0xF7];\n\n  let partNum = 1;\n  statusCallback('Writing');\n  await asyncForEach(hexDataParts, async (part) => {\n    console.log(\"writing part \" + partNum);\n    console.log(part.map(num => num.toString((16))).join(''));\n    if(output) output.write([...sysexStart, ...part, ...sysexEnd]);\n\n    const percentageCompleted = Math.floor(partNum * 1000 / hexDataParts.length) / 10;\n    statusCallback(`${percentageCompleted}% written`);\n    partNum++;\n    await timeout(delayBetweenBlocks); //150ms delay is too fast, 300 works.\n  });\n  statusCallback('Completed');\n  console.log('Sysex write completed');\n};\n\nexport const run = async (output, statusCallback, file) => {\n\n  const settings = getSettings();\n\n  try {\n    const inputfile = await fetchAsText({ url: '', path: 'hexfiles/' + file });\n    const fileLines = inputfile.split('\\n');\n\n    await parseAndUploadFile({\n      sysexAddress: settings.sysexAddress,\n      fileLines,\n      delayBetweenBlocks: 300, // 150ms delay is too fast, 300 works.\n      output,\n      statusCallback,\n    });\n  } catch (err) {\n    console.log('oh damn', err)\n    // cleanup - close midi port etc.\n  }\n\n};\n\n","import React, { Component } from 'react';\nimport './App.css';\nimport { run } from \"./startup\";\n\nclass App extends Component {\n\n  constructor() {\n    super();\n    this.state = {\n      midiAccess: null,\n      outputs: [],\n      selectedOutput: null,\n      selectedFirmware: null,\n      writing: false,\n      statusText: '',\n    }\n  }\n\n  updateOutputs() {\n\n    const { midiAccess, selectedOutput } = this.state;\n\n    const outputs = [];\n\n    midiAccess.outputs.forEach(output => {\n      outputs.push(output);\n    });\n\n    console.log('outputs', outputs);\n\n    this.setState({\n      outputs\n    });\n\n    if (selectedOutput) {\n      if (midiAccess.outputs.get(selectedOutput.id) == null) {\n        console.log('removing selected output');\n        this.setState({ selectedOutput: null });\n      }\n    }\n  }\n\n  async componentDidMount() {\n    const midiAccess = await navigator.requestMIDIAccess({ sysex: true });\n    midiAccess.onstatechange = (e) => {\n      if (e.type === 'statechange' && e.port.type === 'output' && e.port.connection !== 'open') {\n\n        // connection closed or pending - pending if disconnecting after sending something,\n        // connection switches to open on first write.\n\n        //possible states: 'connected', 'disconnected';\n\n        console.log('Midi access changed', e);\n        this.updateOutputs();\n      }\n    };\n    this.setState({\n      midiAccess,\n    });\n    this.updateOutputs();\n  }\n\n  selectOutput(event) {\n    const id = event.target.value;\n    if (id === 'NONE') {\n      console.log('No output selected');\n      this.setState({\n        selectedOutput: null\n      });\n    } else {\n      const output = this.state.midiAccess.outputs.get(id);\n      if (output != null) {\n        console.log('Selected output', id, output);\n        this.setState({\n          selectedOutput: output,\n        });\n      } else {\n        console.log('Could not select output');\n      }\n    }\n  }\n\n  selectFirmware(event) {\n    const firmware = event.target.value;\n    if (firmware === 'NONE') {\n      console.log('No firmware selected');\n      this.setState({\n        selectedFirmware: null\n      });\n    } else {\n      this.setState({\n        selectedFirmware: firmware,\n      });\n\n    }\n  }\n\n  async writeFirmware() {\n    // TODO: Handle failures when device is unplugged while writing\n    if (this.state.selectedOutput === null) {\n      console.log('Cannot write, no output selected');\n      return;\n    }\n    this.setState({ writing: true });\n    await run({\n        write: (bytes) => {\n          this.state.selectedOutput.send(bytes);\n          console.log('Wrote', bytes)\n        }\n      }, (statusText) => {\n        this.setState({ statusText })\n      },\n      this.state.selectedFirmware\n    );\n    this.setState({ writing: false });\n  }\n\n\n  render() {\n\n    const disableButton = this.state.selectedOutput === null || this.state.selectedFirmware === null || this.state.writing;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <select onChange={(event) => this.selectOutput(event)}>\n            <option value='NONE'>Please select a midi output</option>\n            {this.state.outputs.map(\n              output => <option key={output.id} value={output.id}>{output.name}</option>\n            )}\n          </select>\n          <br/>\n          <select onChange={(event) => this.selectFirmware(event)}>\n            <option value='NONE'>Then choose a firmware to upload</option>\n            <option value='mpg200-flash-leds.hex'>Blink leds</option>\n            <option value='mpg200-instant-switch2.hex'>MPG200 instant switch</option>\n          </select>\n          <br/>\n          <button disabled={disableButton} onClick={() => this.writeFirmware()}>Write firmware\n          </button>\n          <p>\n            <div>Status: {this.state.statusText}</div>\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}