{"version":3,"sources":["sysex/hex2sysex.ts","request/request.ts","config.ts","settings.ts","startup.ts","App.tsx","serviceWorker.js","index.tsx"],"names":["OUT_CMD_ADDR","getEmptyBytes","numberOfWholeBytes","bytes","i","push","getHexStringAsByteArray","byteString","length","parseInt","substring","getAsHalfBytes","halfBytes","Array","forEach","byte","Math","floor","num","reverse","parseLines","lines","dataBlocks","mode","addressOffset","lineNum","line","dataLength","originalAddress","dataEnd","address","type","data","checksum","parseLine","console","log","getMode","getModeString","toString","getMissingEndBytes","blockSize","mergeAndPadBlocks","blocks","currentBlock","mergedBlocks","currentAddress","currentEndBlockNum","block","blockNum","getStartBlockNum","missingBytes","getEndBlockNum","lastMerged","splitByBlockSize","splitBlocks","sliceData","slice","dataString","join","convertFileToSysex","fileLines","a","parsedBlocks","filter","sort","b","mergedProgramBlocks","splitProgramBlocks","sysexBlocks","map","fetchAsText","url","path","fetch","then","response","text","fetchAsJson","json","config","sysexAddress","xonikAddress","getAddress","fieldname","addressBytes","split","trim","Error","timeout","ms","Promise","res","setTimeout","asyncForEach","sysexDataList","callback","index","parseAndUploadFile","output","delayBetweenBlocks","statusCallback","sysexStart","sysexEnd","partNum","sysexData","write","percentageCompleted","run","file","settings","endsWith","inputFile","App","options","state","midiAccess","outputs","selectedOutput","selectedFirmware","writing","statusText","this","setState","get","id","navigator","requestMIDIAccess","sysex","onstatechange","e","port","connection","updateOutputs","event","target","value","firmware","send","disableButton","className","onChange","selectOutput","key","name","selectFirmware","disabled","onClick","writeFirmware","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.86349fc5.chunk.js","sourcesContent":["import { ByteArray, SysexData } from '../types';\n\ntype Type = number;\ntype Mode = number;\n\ninterface ParsedLine {\n  dataLength: number,\n  address: number,\n  originalAddress: number,\n  type: Type,\n  data: string,\n  checksum: string,\n}\n\ninterface DataBlock {\n  address: number,\n  data: ByteArray,\n  mode: Mode,\n  checksum: string,\n}\n\ninterface MergedDataBlock {\n  address: number,\n  data: ByteArray,\n}\n\n\n\nexport const TYPE_DATA = 0;\nexport const TYPE_EOF = 1;\nexport const TYPE_LINEAR_ADDR = 2;\nexport const TYPE_EXTENDED_ADDR = 4;\n\nexport const MODE_UNKNOWN = -1;\nexport const MODE_PROGRAM = 0;\nexport const MODE_CONFIG = 1;\nexport const MODE_EEPROM = 2;\nexport const MODE_USER_ID = 3;\n\nconst EXT_ADDR_PROGRAM = '0000';\nconst EXT_ADDR_USER_ID = '0020';\nconst EXT_ADDR_CONFIG_BYTES = '0030';\nconst EXT_ADDR_EEPROM_BYTES = '00F0';\n\nconst OUT_CMD_ADDR = 0x10;\nconst OUT_CMD_DATA = 0x11;\nconst OUT_CMD_EOF = 0x12;\n\n// TODO: THIS MAY NOT WORK WITH PIC18F, may have to be 1\nconst BYTES_PR_WORD = 2;\n\n/*\nconst getTypeString = (type: Type) => {\n  switch (type) {\n    case TYPE_DATA:\n      return 'data';\n    case TYPE_EOF:\n      return 'eof';\n    case TYPE_LINEAR_ADDR:\n      return 'linear address';\n    case TYPE_EXTENDED_ADDR:\n      return 'extended address';\n    default:\n      return 'unknown';\n\n  }\n};\n*/\n\nconst getModeString = (mode: Mode) => {\n  switch (mode) {\n    case MODE_PROGRAM:\n      return 'program bytes';\n    case MODE_CONFIG:\n      return 'user id';\n    case MODE_EEPROM:\n      return 'config bytes';\n    case MODE_USER_ID:\n      return 'eeprom bytes';\n    default:\n      return 'unknown';\n\n  }\n};\n\nexport const getEmptyBytes = (numberOfWholeBytes: number): ByteArray => {\n  const bytes = [];\n  for (let i = 0; i < numberOfWholeBytes; i++) {\n    bytes.push(255);\n  }\n  return bytes;\n};\n\nexport const getHexStringAsByteArray = (byteString: string): ByteArray => {\n  const bytes = [];\n  for (let i = 0; i < byteString.length; i += 2) {\n    bytes.push(parseInt(byteString.substring(i, i + 2), 16));\n  }\n  return bytes;\n};\n\nexport const getAsHalfBytes = (bytes: Array<number> | number): ByteArray => {\n  const halfBytes: number[] = [];\n  if (bytes instanceof Array) {\n    bytes.forEach(byte => {\n      halfBytes.push(Math.floor(byte / 16));\n      halfBytes.push((byte + 16) % 16);\n    });\n    return halfBytes;\n  } else {\n    let num = bytes;\n    do {\n      halfBytes.push((num + 16) % 16);\n      num = num >> 4;\n      halfBytes.push((num + 16) % 16);\n      num = num >> 4;\n    } while (num !== 0);\n\n    return halfBytes.reverse();\n  }\n};\n\ninterface SplitBlock {\n  data: ByteArray,\n  dataString: string,\n  address: number,\n}\n\nexport const parseLine = (line: string, addressOffset: number): ParsedLine => {\n  const dataLength = parseInt(line.substring(1, 3), 16);\n  const originalAddress = parseInt(line.substring(3, 7), 16);\n  const address = addressOffset + originalAddress;\n  const type = parseInt(line.substring(7, 9), 16);\n  const dataEnd = 9 + dataLength * 2;\n  const data = line.substring(9, dataEnd);\n  const checksum = line.substring(dataEnd, dataEnd + 2);\n\n  return {\n    dataLength,\n    address,\n    originalAddress,\n    type,\n    data,\n    checksum,\n  };\n};\n\nexport const getMode = (data: string) => {\n  if(data === EXT_ADDR_PROGRAM){\n    return MODE_PROGRAM;\n  } else if (data === EXT_ADDR_CONFIG_BYTES) {\n    return MODE_CONFIG;\n  } else if (data === EXT_ADDR_EEPROM_BYTES) {\n    return MODE_EEPROM;\n  } else if (data === EXT_ADDR_USER_ID) {\n    return MODE_USER_ID;\n  } else {\n    return MODE_UNKNOWN;\n  }\n};\n\nexport const parseLines = (lines: Array<string>): DataBlock[] => {\n  const dataBlocks: DataBlock[] = [];\n  let mode = MODE_PROGRAM;\n  let addressOffset = 0;\n  let lineNum = 1;\n  lines.forEach(line => {\n\n    // remove lines not containing instructions\n    if (line.substring(0, 1) === ':') {\n      const { type, address, originalAddress, data, checksum } = parseLine(line, addressOffset);\n\n      if (type === TYPE_LINEAR_ADDR) {\n        addressOffset = 16 * parseInt(data, 16);\n        console.log(`${lineNum} changed address offset to ${addressOffset} (${line})`);\n      } else if (type === TYPE_EXTENDED_ADDR) {\n        addressOffset = 65536 * parseInt(data, 16);\n        mode = getMode(data);\n        console.log(`${lineNum} changed address offset to ${addressOffset}, mode: ${getModeString(mode)} (${line})`);\n      } else if (type === TYPE_DATA) {\n        // TODO: No address offset for EEPROM ETC?\n        dataBlocks.push({\n          address,\n          data: getHexStringAsByteArray(data),\n          mode,\n          checksum,\n        });\n        console.log(`${lineNum}, addr: 0x${address.toString(16)} (${address}), orig: 0x${originalAddress.toString(16)}, bytes: ${data.length / 2}, data: ${data}`);\n      } else if(type === TYPE_EOF){\n        console.log(`EOF found, address: ${address}, data: ${data}, checksum: ${checksum}`);\n      } else {\n        console.log(\"Unknown type encountered: \", type, address, data, checksum);\n      }\n    } else {\n      console.log(\"Unknown line format encountered: \", line)\n    }\n    lineNum++;\n  });\n\n  console.log('Finished parsing lines');\n  return dataBlocks;\n};\n\nexport const getBlockAlignedAddress = (address: number, blockSize: number) => {\n  return Math.floor(address / blockSize) * blockSize;\n};\n\nexport const getStartBlockNum = (address: number, blockSize: number) => {\n  return Math.floor(address / blockSize);\n};\n\nexport const getEndBlockNum = (address: number, length: number, blockSize: number) => {\n  return Math.floor((address + length) / blockSize);\n};\n\nexport const getMissingEndBytes = (address: number, length: number, blockSize: number) => {\n  return blockSize - (blockSize + address + length) % blockSize; // adding blockSize to prevent negative number. % in js is weird.\n};\n\nexport const mergeAndPadBlocks = (blocks: DataBlock[], blockSize: number): MergedDataBlock[] => {\n  const mergedBlocks: MergedDataBlock[] = [];\n  let currentBlock: MergedDataBlock;\n  let currentAddress = 0;\n  let currentEndBlockNum = -2;\n\n  blocks.forEach(block => {\n    const blockNum = getStartBlockNum(block.address, blockSize);\n\n    // if there is at least one full block between entries, create a new merged block.\n    if (blockNum !== currentEndBlockNum && blockNum !== currentEndBlockNum + 1) {\n      // add missing bytes from last block\n      if (currentBlock != null) {\n        const missingBytes = getMissingEndBytes(currentAddress, 0, blockSize);\n        if (missingBytes) {\n          currentBlock.data.push(...getEmptyBytes(missingBytes));\n        }\n      }\n\n      // create new block\n      currentAddress = blockNum * (blockSize / BYTES_PR_WORD);\n      currentBlock = {\n        address: currentAddress,\n        data: [],\n      };\n      mergedBlocks.push(currentBlock);\n    }\n\n    // add missing bytes between blocks\n    const missingBytes = block.address - currentAddress;\n    if (missingBytes) {\n      currentBlock.data.push(...getEmptyBytes(missingBytes));\n    }\n    currentBlock.data.push(...block.data);\n\n    currentEndBlockNum = getEndBlockNum(block.address, block.data.length, blockSize);\n    currentAddress = block.address + block.data.length;\n  });\n\n  // add bytes missing from the last merged block - missing end bytes are normally added on the\n  // next iteration, but the last block has no next.\n  const lastMerged = mergedBlocks[mergedBlocks.length - 1];\n  const missingBytes = getMissingEndBytes(lastMerged.address, lastMerged.data.length, blockSize);\n  lastMerged.data.push(...getEmptyBytes(missingBytes));\n  return mergedBlocks;\n};\n\nexport const splitByBlockSize = (mergedBlocks: MergedDataBlock[], blockSize: number) => {\n  // split blocks to block size\n  const splitBlocks: SplitBlock[] = [];\n\n  mergedBlocks.forEach(block => {\n    for (let i = 0; i < block.data.length; i += blockSize) {\n      const sliceData = block.data.slice(i, i + blockSize);\n      splitBlocks.push({\n        data: sliceData,\n        dataString: sliceData.join(),\n        address: block.address + (i / BYTES_PR_WORD)\n      });\n    }\n  });\n  return splitBlocks;\n};\n\nexport const convertFileToSysex = async (\n  fileLines: Array<string>, blockSize: number): Promise<SysexData[]> => {\n  const parsedBlocks = parseLines(fileLines);\n\n  // Data blocks may not be ordered by address. In order to pad the blocks correctly we have to\n  // sort them.\n  const dataBlocks = parsedBlocks\n    .filter(block => block.mode === MODE_PROGRAM)\n    .sort((a, b) => a.address - b.address);\n\n  const mergedProgramBlocks = mergeAndPadBlocks(dataBlocks, blockSize);\n  const splitProgramBlocks = splitByBlockSize(mergedProgramBlocks, blockSize);\n\n  const sysexBlocks = splitProgramBlocks.map(block => {\n    return [\n      OUT_CMD_ADDR,\n      ...getAsHalfBytes(block.address),\n      OUT_CMD_DATA,\n      ...getAsHalfBytes(block.data),\n    ]\n  });\n  sysexBlocks.push([OUT_CMD_EOF]);\n  return sysexBlocks;\n};\n","interface Request {\n  url: string | undefined;\n  path: string;\n}\n\nexport const fetchAsText =  ({url, path}:  Request) => {\n  return fetch(`${url}${path}`)\n    .then(response => {\n      return response.text();\n    });\n};\n\nexport const fetchAsJson =  ({url, path}:  Request) => {\n  return fetch(`${url}${path}`)\n    .then(response => {\n      return response.json();\n    });\n};\n","//NB! Must match settings in commandline tool as well\nconst config = {\n  sysexAddress: '0x00, 0x2B, 0x60',\n  xonikAddress: '0x22, 0x50, 0x50',\n};\n\nexport default config;","import config from './config';\n\nconst getAddress = (address: string, fieldname: string) => {\n  const addressBytes = address\n    .split(',')\n    .map(byte => byte.trim())\n    .map(byte => parseInt(byte));\n\n  if (addressBytes.length !== 3) {\n    throw Error(fieldname + \" must be exactly 3 bytes long.\");\n  }\n  console.log(`Using ${fieldname} ${addressBytes[0]}, ${addressBytes[1]}, ${addressBytes[2]}`);\n  return addressBytes;\n\n};\n\nexport const getSettings = () => {\n\n  const sysexAddress = getAddress(config.sysexAddress, 'sysexAddress');\n  const xonikAddress = getAddress(config.xonikAddress, 'xonikAddress');\n\n  return {\n    sysexAddress,\n    xonikAddress,\n  }\n};","import { convertFileToSysex } from './sysex/hex2sysex';\nimport { fetchAsJson, fetchAsText } from './request/request';\nimport { getSettings } from './settings';\nimport { SysexData } from './types';\n\ninterface Output {\n    write: (bytes: number[] | Uint8Array) => void;\n}\n\nconst timeout = (ms: number) => new Promise(res => setTimeout(res, ms));\n\nconst asyncForEach = async (sysexDataList: SysexData[], callback: (sysexData: SysexData) => void) => {\n    for (let index = 0; index < sysexDataList.length; index++) {\n        await callback(sysexDataList[index]);\n    }\n};\n\ninterface ParseAndUploadParams {\n    sysexAddress: number[];\n    xonikAddress: number[];\n    sysexDataList: number[][];\n    output: Output;\n    delayBetweenBlocks: number;\n    statusCallback: (statusText: string) => void;\n}\n\nconst parseAndUploadFile = async (\n    {\n        sysexAddress,\n        xonikAddress,\n        sysexDataList,\n        output,\n        delayBetweenBlocks,\n        statusCallback,\n    }: ParseAndUploadParams\n) => {\n    const sysexStart = [0xF0, ...sysexAddress, ...xonikAddress];\n    const sysexEnd = [0xF7];\n\n    let partNum = 1;\n    statusCallback('Writing');\n    await asyncForEach(sysexDataList,\n        async (sysexData) => {\n            console.log('writing part ' + partNum);\n            console.log(sysexData.map((num: number) => num.toString((16))).join(''));\n            if (output) {\n                output.write([...sysexStart, ...sysexData, ...sysexEnd]);\n            }\n\n            const percentageCompleted = Math.floor(partNum * 1000 / sysexDataList.length) / 10;\n            statusCallback(`${percentageCompleted}% written`);\n            partNum++;\n            await timeout(delayBetweenBlocks); //150ms delay is too fast, 300 works.\n        });\n    statusCallback('Completed');\n    console.log('Sysex write completed');\n};\n\nexport const run = async (\n    output: Output,\n    statusCallback: (statusText: string) => void,\n    file: string,\n) => {\n\n    const settings = getSettings();\n\n    try {\n        if (file.endsWith('.xonik')) {\n            const sysexDataList = await fetchAsJson({ url: '', path: 'firmwares/' + file });\n            await parseAndUploadFile({\n                sysexAddress: settings.sysexAddress,\n                xonikAddress: settings.xonikAddress,\n                sysexDataList,\n                delayBetweenBlocks: 300, // 150ms delay is too fast, 300 works.\n                output,\n                statusCallback,\n            });\n        } else {\n            //hex files\n            const inputFile = await fetchAsText({ url: '', path: 'hexfiles/' + file });\n            const fileLines = inputFile.split('\\n');\n            const sysexDataList = await convertFileToSysex(fileLines, 64);\n\n            await parseAndUploadFile({\n                sysexAddress: settings.sysexAddress,\n                xonikAddress: settings.xonikAddress,\n                sysexDataList,\n                delayBetweenBlocks: 300, // 150ms delay is too fast, 300 works.\n                output,\n                statusCallback,\n            });\n        }\n    } catch (err) {\n        console.log('oh damn', err);\n        // cleanup - close midi port etc.\n    }\n\n};\n\n","import React, { Component } from 'react';\nimport './App.css';\nimport { run } from \"./startup\";\n\ninterface Props {\n\n}\n\ninterface State {\n  midiAccess: WebMidi.MIDIAccess | null,\n  outputs: WebMidi.MIDIOutput[],\n  selectedOutput: WebMidi.MIDIOutput | null,\n  selectedFirmware: string | null,\n  statusText: string,\n  writing: boolean,\n}\n\nclass App extends Component<Props, State> {\n\n  constructor(options: any) {\n    super(options);\n    this.state = {\n      midiAccess: null,\n      outputs: [],\n      selectedOutput: null,\n      selectedFirmware: null,\n      writing: false,\n      statusText: '',\n    }\n  }\n\n  updateOutputs() {\n\n    const { midiAccess, selectedOutput } = this.state;\n\n    if(!midiAccess){\n      console.log(\"No midiaccess available, aborting\");\n      return;\n    }\n    const outputs: WebMidi.MIDIOutput[] = [];\n\n    midiAccess.outputs.forEach(output => {\n      outputs.push(output);\n    });\n\n    console.log('outputs', outputs);\n\n    this.setState({\n      outputs\n    });\n\n    if (selectedOutput) {\n      if (midiAccess.outputs.get(selectedOutput.id) == null) {\n        console.log('removing selected output');\n        this.setState({ selectedOutput: null });\n      }\n    }\n  }\n\n  async componentDidMount() {\n    const midiAccess = await navigator.requestMIDIAccess({ sysex: true });\n    midiAccess.onstatechange = (e) => {\n      if (e.type === 'statechange' && e.port.type === 'output' && e.port.connection !== 'open') {\n\n        // connection closed or pending - pending if disconnecting after sending something,\n        // connection switches to open on first write.\n\n        //possible states: 'connected', 'disconnected';\n\n        console.log('Midi access changed', e);\n        this.updateOutputs();\n      }\n    };\n    this.setState({\n      midiAccess,\n    });\n    this.updateOutputs();\n  }\n\n  selectOutput(event: React.ChangeEvent<HTMLSelectElement>) {\n    if(!this.state.midiAccess){\n      console.log(\"Weird, no midi access available. Aborting select output\");\n      return;\n    }\n    const id = event.target.value;\n    if (id === 'NONE') {\n      console.log('No output selected');\n      this.setState({\n        selectedOutput: null\n      });\n    } else {\n      const output = this.state.midiAccess.outputs.get(id);\n      if (output != null) {\n        console.log('Selected output', id, output);\n        this.setState({\n          selectedOutput: output,\n        });\n      } else {\n        console.log('Could not select output');\n      }\n    }\n  }\n\n  selectFirmware(event: React.ChangeEvent<HTMLSelectElement>) {\n    const firmware = event.target.value;\n    if (firmware === 'NONE') {\n      console.log('No firmware selected');\n      this.setState({\n        selectedFirmware: null\n      });\n    } else {\n      this.setState({\n        selectedFirmware: firmware,\n      });\n\n    }\n  }\n\n  async writeFirmware() {\n    // TODO: Handle failures when device is unplugged while writing\n    if (this.state.selectedOutput == null || this.state.selectedFirmware == null) {\n      console.log('Cannot write, no output or firmware selected');\n      return;\n    }\n    this.setState({ writing: true });\n    await run({\n        write: (bytes: number[] | Uint8Array) => {\n          if(!this.state.selectedOutput){\n            return\n          }\n          this.state.selectedOutput.send(bytes);\n          console.log('Wrote', bytes)\n        }\n      }, (statusText: string) => {\n        this.setState({ statusText })\n      },\n      this.state.selectedFirmware\n    );\n    this.setState({ writing: false });\n  }\n\n\n  render() {\n\n    const disableButton = this.state.selectedOutput === null || this.state.selectedFirmware === null || this.state.writing;\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <select onChange={(event) => this.selectOutput(event)}>\n            <option value='NONE'>Please select a midi output</option>\n            {this.state.outputs.map(\n              output => <option key={output.id} value={output.id}>{output.name}</option>\n            )}\n          </select>\n          <br/>\n          <select onChange={(event) => this.selectFirmware(event)}>\n            <option value='NONE'>Then choose a firmware to upload</option>\n            <option value='mpg200.xonik'>MPG200 xonik</option>\n          </select>\n          <br/>\n          <button disabled={disableButton} onClick={() => this.writeFirmware()}>Write firmware\n          </button>\n          <p>\n            Status: {this.state.statusText}\n          </p>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}